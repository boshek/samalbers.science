{
  "hash": "be2559d3f7ba1b902b471588f4f9fffd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How I am making a listcol in pyarrow\nauthor: Sam Albers\ndate: last-modified\nslug: hockey-age-with-ojs\ncategories:\n  - R\n  - Python\n  - arrow\n  - parquet\ntags: []\n\ndescription: ''\nfeatured: ''\nfeaturedalt: ''\nfeaturedpath: ''\nlinktitle: ''\ntype: post\nexecute: \n  warning: false\n---\n\n\n\nArrow, parquet and interoperability between languages in 2024 has come so far. In particular [Apache Arrow](https://arrow.apache.org/) provides us common types across languages. This type of consistency makes hand-offs between languages much simpler because we don't have to manually find equivalent types that behave approximately the same. However, sometimes you still have to find the right way to organize your data, in a type that arrow knows, so that it will map correctly to a type that you might be used to working with. \n\nThis post is about constructing something that resembles a [list column](https://tidyr.tidyverse.org/articles/nest.html) in R but you have to start out in python. List columns (also called nested data) are a really attractive data structure. The same idea exists in JSON but nested data in a dataframe just makes more sense to my brain. It also for more efficient data storage as you aren't repeating attribute columns across every row of your nested values. For example, consider this hydrometric data from [tidyhydat](https://docs.ropensci.org/tidyhydat/)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyhydat)\nriver_df <- hy_daily_flows(\"08MF005\")\nriver_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Queried from version of HYDAT released on 2024-07-18\n   Observations:                      40,848\n   Measurement flags:                 2,020\n   Parameter(s):                      Flow\n   Date range:                        1912-03-01 to 2023-12-31 \n   Station(s) returned:               1\n   Stations requested but not returned: \n    All stations returned.\n# A tibble: 40,848 × 5\n   STATION_NUMBER Date       Parameter Value Symbol\n   <chr>          <date>     <chr>     <dbl> <chr> \n 1 08MF005        1912-03-01 Flow        538 <NA>  \n 2 08MF005        1912-03-02 Flow        538 <NA>  \n 3 08MF005        1912-03-03 Flow        538 <NA>  \n 4 08MF005        1912-03-04 Flow        538 <NA>  \n 5 08MF005        1912-03-05 Flow        538 <NA>  \n 6 08MF005        1912-03-06 Flow        538 <NA>  \n 7 08MF005        1912-03-07 Flow        479 <NA>  \n 8 08MF005        1912-03-08 Flow        479 <NA>  \n 9 08MF005        1912-03-09 Flow        459 <NA>  \n10 08MF005        1912-03-10 Flow        459 <NA>  \n# ℹ 40,838 more rows\n```\n\n\n:::\n:::\n\n\n\nWe have lots of repeated column values across many river discharge values. Instead if we nested the data we get one row per station/ \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\nnested_river_df <- nest(river_df, .by = c(STATION_NUMBER, Parameter), .key = \"flow_data\")\nnested_river_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  STATION_NUMBER Parameter flow_data        \n  <chr>          <chr>     <list>           \n1 08MF005        Flow      <hy [40,848 × 3]>\n```\n\n\n:::\n:::\n\n\n\nThis opens up some nice possibilities to do some calculations on `flow_data` but still maintain that single row per station data model using the purrr package. For example here we could sum the river discharge values by year then take the average of that and return a single value per station. This is a powerful feature that can keep your data compact and intutitive.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nnested_river_df |>\n  mutate(\n    avg_annual_value = map_dbl(\n      flow_data, ~ {\n        .x |>\n          group_by(year = year(Date)) |>\n          summarise(sum_flows = sum(Value, na.rm = TRUE)) |>\n          summarise(avg_val = mean(sum_flows)) |>\n          pull(avg_val)\n      }\n    ), .before = flow_data\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  STATION_NUMBER Parameter avg_annual_value flow_data\n  <chr>          <chr>                <dbl> <list>   \n1 08MF005        Flow               994145. <hy>     \n```\n\n\n:::\n:::\n\n\n\n\nRecently I wanted to construct something that resembled a list column in a python data pipeline which was then handed off to R. So this post is a learning of how to do that in python. \n\n\n```python\nimport pyarrow as pa\nimport seaborn as sns\n\n# Load iris dataset\niris = sns.load_dataset('iris')\n\n# Convert pandas DataFrame to pyarrow Table\niris_table = pa.Table.from_pandas(iris)\n\n# Columns to nest (other than 'Species')\ncolumns_to_nest = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']\n\n# Create the aggregation list\naggregations = [(col, 'list') for col in columns_to_nest]\n\n# Group by 'Species' and aggregate the other columns into lists\ngrouped = iris_table.group_by(['species']).aggregate(aggregations)\n\n# Output the resulting table\nprint(grouped)\n\ngrouped.to_pandas()\n```",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}