---
title: Defying Age with Observable
author: Sam Albers
date: last-modified
slug: intro-to-ojs
categories:
  - R
  - JavaScript
  - Observable
  - nhl
  - api
tags: []
description: ''
featured: ''
featuredalt: ''
featuredpath: ''
linktitle: ''
type: post
---

Lately I've been thinking about two things: getting old and Observable. Getting old is self-explanatory. Observable is maybe less so. Normally Observable is a [JavaScript notebook environment](https://observablehq.com/@observablehq) that enables you to create interactive visualizations. This is a great platform and I suggest that if you are really interested in learning about Observable, you create an account there and start practicing. But sometimes, you want to take your interactive visualizations with you. This is where [quarto](https://quarto.org/) comes in. Quarto is the successor to [rmarkdown](https://rmarkdown.rstudio.com/) and is what this blog is written in. Like rmarkdown you can write prose and code in the same document. The biggest improvement with quarto is that you can also easily write code chunks in other language like python or observable flavoured JavaScript. 

This post was intended to be about Observable and quarto using some data sourced from the National Hockey League api. So back to being the them of being old -- I was wondering what happens to N.H.L. players when they get old? I was not able to find an interactive visualizations that satifactorily provided any ability to explore the question "At what age do N.H.L. players start declining in terms of production"?  So then I ended having to learn about the NHL api and how I could get what I wanted out of it. That turned this into a post about wrangling data from the N.H.L. api. Almost accidentally, this really highlights the power of quarto. I can much more easily wrangle data in R. Sure it is possible to do solely in JavaScript but for me it is easier in R. But then when I want to make the visualization, I can seamlessly switch to JavaScript in quarto. 

Let's start with how we got the data. As is usual, we start with a pretty standard suite of tidyverse packages. 


```{r pkgs}
#| warning: false
library(httr2)
library(purrr)
library(dplyr)
library(glue)
library(tidyr)
```

## Define some helper functions

Next we need to define some helper functions.

```{r}
convert_time <- function(time_str) {
  # Split the time into minutes and seconds
  time_parts <- strsplit(time_str, ":")[[1]]
  # Convert to integers
  minutes <- as.integer(time_parts[1])
  seconds <- as.integer(time_parts[2])
  # Convert the time to seconds
  minutes*60 + seconds
}

generate_year_string <- function(start, end) {
  # Extract the starting and ending years
  startYear <- as.numeric(substr(start, 1, 4))
  endYear <- as.numeric(substr(end, 1, 4))
  # Generate the sequence of years
  years <- seq(startYear, endYear)
  # Concatenate each year with the following one to get the year pairs
  paste0(years, years + 1)
}
```

`convert_time` turns a time string like `824:13` into the number of seconds. 

```{r}
convert_time("824:13")
```

`generate_year_string` is a helper function to generate the year strings that the N.H.L. api expects.
```{r}
generate_year_string(19951996, 19981999)
```

This is a function to help sending messages to the console. Defining it here saves lots of space where I use it later on. 
```{r}
api_message <- function(..., verbose = TRUE) {
  if (verbose) {
    message(...)
  }
  invisible(TRUE)
}
```

`query_endpoint` is the core function that actually sends a data request to the N.H.L. api. It takes an endpoint and a list of query parameters and returns a tibble with the results. It is always helpful to isolate the code that does the querying from the code that does the data wrangling.

```{r}
query_endpoint <- function(endpoint, ...) {
  base_url <- "https://statsapi.web.nhl.com/"
  req <- httr2::request(base_url) %>%
    httr2::req_url_path_append(endpoint)  %>% 
    httr2::req_url_query(...)

  resp <- httr2::req_perform(req)

  parsed <- httr2::resp_body_json(resp, simplifyVector = TRUE)
  parsed$copyright <- NULL
  dplyr::as_tibble(parsed[[1]])
}
```

With every request to the N.H.L. api, the following note is returned in the response, specifying exactly who owns all the tradeamarks and logos. We drop it from the response because it is not really useful for our purposes but I am replicating it here:

:::{.callout-note}
NHL and the NHL Shield are registered trademarks of the National Hockey League. NHL and NHL team marks are the property of the NHL and its teams. Â© NHL 2023. All Rights Reserved.
:::

The `get_points_by_age` is the workhorse function for this post but is also one of those functions that does what you want it but if you were to try and copy it over, it might not behave the way you think it should. The code is annotated (another cool feature of quarto) to outline steps of this functions.

```{r}
#| code-annotations: hover
get_points_by_age <- function(team, min_games_played, verbose = FALSE) {
  api_message(glue("Getting data for {team}."), verbose = verbose)

  team_df <- query_endpoint("api/v1/teams") %>% # <1>
    filter(teamName == team)

  team_plus_roster <- query_endpoint(team_df$link, expand = "team.roster") # <2>

  ## Drop goalies
  roster <- team_plus_roster[["roster"]][["roster"]][[1]]
  person_link <- roster[roster$position != "G", ][["person"]]$link # <3>
  person_link <- person_link[!is.na(person_link)]

  roster_with_ages <- map_df(seq_along(person_link), ~ { # <4>
    query_endpoint(person_link[.x]) %>%
      select(id, fullName, link, birthDate, currentAge) %>%
      mutate(birthDate = as.Date(birthDate))
  })

  point_per_60_by_season <- map_df(seq_along(roster_with_ages$link), ~ {
    query_url <- glue("{roster_with_ages$link[.x]}/stats")

    map_df(generate_year_string("19901991", "20222023"), \(season) {
      stats <- query_endpoint( # <6>
        query_url,
        stats = "statsSingleSeason",
        season = season
      )

      ## when there are no stats, return an empty tibble
      if (length(stats[["splits"]][[1]]) == 0) {
        api_message(glue("No data for {roster_with_ages$fullName[.x]} for the {season} season", verbose = verbose))
        return(tibble())
      }
      api_message(glue("Getting data for {roster_with_ages$fullName[.x]} for the {season} season", verbose = verbose))

      games_played_threshold <- stats[["splits"]][[1]][["stat"]] %>% # <7>
        filter(games > min_games_played)

      ## when they are not above the threshold, return an empty tibble
      if (nrow(games_played_threshold) == 0) {
        api_message(glue("{roster_with_ages$fullName[.x]} did not play at least {min_games_played} games in the {season} season", verbose = verbose))
        return(tibble())
      }

      games_played_threshold %>%
        mutate(evenTimeOnIce = convert_time(evenTimeOnIce)) %>%
        mutate(even_strength_points = points - powerPlayPoints) %>%
        mutate(even_strength_points_per_60 = (even_strength_points / evenTimeOnIce) * 3600) %>% # <8>
        select(even_strength_points_per_60, shotPct) %>%
        mutate(person_link = person_link[.x]) %>%
        mutate(season = season)
    })
  })

  if (length(point_per_60_by_season) == 0) {
    api_message(glue("No players over found for {team}.", verbose = verbose))
    return(tibble())
  } else {
    point_per_60_by_season %>%
      mutate(team = team) %>%
      left_join(roster_with_ages, by = c("person_link" = "link")) %>%
      mutate(age_at_start_of_season = currentAge - (2022 - as.numeric(substr(season, 1, 4)))) %>% # <9>
      filter(!is.na(fullName)) %>%
      relocate(fullName, birthDate, season, team, .before = even_strength_points_per_60) %>% 
      as_tibble() # <10>
  }
}
```

1. Get the team id from the team name
2. Get the roster for that team
3. Filter out the goalies
4. Query for the age of each player on the roster
5. Filter out players that are younger than the age cutoff
6. Get the stats for each player for each season when they actually played
7. Filter out the players that don't meet the minimum games played threshold
8. Calculate the points per 60 minutes for each player
9. Calculate the age of the player at the start of the season
10. Return a tibble with the results

## Use the helper functions to get the data

The way that I've written `get_points_by_age`, you supply it a team name and it will look for stats on those players that are currently on the roster. So you would invoke it like this:
```{r}
#| eval: false
get_points_by_age("Penguins", min_games_played = 60)
```

However, since we are interested in all players in the N.H.L. we need all teams. Here we use `map_df` to iterate over each team and then bind the results together into a single tibble. This the data we will working with. 

```{r}
#| echo: true
#| eval: false

teams <- query_endpoint("api/v1/teams")
age_curve_df <- map_df(
  teams$teamName,
  get_points_by_age,
  min_games_played = 40,
  verbose = interactive()
)
```

```{r}
#| eval: true
#| echo: false

# readr::write_csv(age_curve_df, "age_curve.csv")
(age_curve_df <- readr::read_csv("age_curve.csv", show_col_types = FALSE))
```

## The pass off to Observable JavaScript

Now that we have the data, we can pass it off to JavaScript. We do this by using the `ojs_define` function. This function is available in R and python and it allows you to make data available in an ojs chunk. The `age_curve_df` data we gathered in the previous steps will now be available in the ojs chunk below as `ojs_age_curve_df`.

```{r}
ojs_define(ojs_age_curve_df = age_curve_df)
```

## Working with Observable JavaScript

The rest of the code in this post is all written in JavaScript. 

We do need import some libraries (just like R) that don't automatically come bundled with quarto. We are grabbing the [arquero data wrangling](https://uwdata.github.io/arquero/) library which as far as I can tell, is more or less dplyr for Observable JavaScript. Here is how they describe it:

> Following the relational algebra and inspired by the design of dplyr, Arquero provides a fluent API for manipulating column-oriented data frames.

Cool! I know I said that I was going to do most of my data warangling in R but it really does help to be able to do some of it in JavaScript.

```{ojs}
import { aq, op } from '@uwdata/arquero';
```

The first function that we are is `aq.from` which is the equivalent of `dplyr::as_tibble`. It takes a data frame and converts it to an arquero table.

```{ojs}
ageCurve = aq.from(transpose(ojs_age_curve_df))
ageCurve.view()
```

Now we can do some data wrangling! Remember that we data coalated in the R step. The question we were interested in looking at was _at what age do players start to decline?_ Our evaluation metric is even strength points per 60 minutes. Say, we are interested in looking at playing time for players that are 35 and older. We can filter the `ageCurve` table using syntax that is very similar to dplyr. The only thing to note is what goes inside the `aq.escape` function. This is because we are using a JavaScript function inside of a JavaScript function. This escapes the inner function so that it is evaluated as JavaScript. 

```{ojs}
//| eval: false
ageCurve
  .filter(aq.escape(d => d.currentAge > 35)) 
```

Ok but you might asking yourself, why don't I just do that in dplyr? The beauty of these `ojs` chunks is that we can perform these operations on the fly using interactive tools like sliders, dropdown menus and radio buttons. For that we make use of Observable [`Inputs`](https://observablehq.com/@observablehq/inputs). Let's make two of these: a slider and a dropdown. The slider (via `Inputs.range`) defines the variable `age_cutoff` and we can use _that_ value to filter the `ageCurve` table updating the `filteredAgeCurve` data in real time. We then take the `filteredAgeCurve` to determine unique player names and provide those as the values in the dropdown menu (via `Inputs.select`). One consequence of that is the values in the dropdown menu are dependent on the slider. Check for yourself! There are many fewer players at the age cutoff of 35.  

```{ojs}
viewof age_cutoff = Inputs.range([18, 40], {step: 1, value: 30})

filteredAgeCurve = ageCurve
  .filter(aq.escape(d => d.currentAge > age_cutoff)) 

viewof player = Inputs.select(filteredAgeCurve.dedupe("fullName").orderby("fullName").array("fullName"), {
  value: "Sidney Crosby"
})

singlePlayer = filteredAgeCurve
  .filter(aq.escape(d => d.fullName == player)) 
```

It doesn't get too exciting though until we start to visualize it. I am using the `code-fold: true` chunk option to hide the code that generates the plot so that you can see the plot, the slider and the dropdown more closely together.

```{ojs}
//| code-fold: true
Plot.plot({
  y: {
    grid: true,
    label: "Even Strength Points per 60"
  },
  x: {
    grid: true,
    label: "Age at the start of the season"
  },
  marks: [
    Plot.lineY(filteredAgeCurve, {
        x: "age_at_start_of_season", 
        y: "even_strength_points_per_60", 
        z: "fullName",
        stroke: "lightgray",
        curve: "basis"
      }),
    Plot.lineY(singlePlayer, {
        x: "age_at_start_of_season", 
        y: "even_strength_points_per_60", 
        z: "fullName",
        stroke: "blue",
        curve: "basis"
      })
  ]
})
```



Ok so the players that are above 35... are pretty good. Like really good actually. So obviously there is so selection bias going on here. The players that are playing at 35 are the best of the best. There is not a huge drop off for them.


